(*
This file is generated by Cogent

*)

theory Generated_Shallow_Desugar
imports "Generated_ShallowShared"
begin

definition
  snd :: "('a, 'b) RR \<Rightarrow> 'b"
where
  "snd ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>3). Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>4. b)))"

definition
  second :: "('b \<Rightarrow> 'b', ('a, 'b) RR) RR \<Rightarrow> ('a, 'b') RR"
where
  "second ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(f,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 RR.p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>5). RR.make a (f b)))))"

definition
  min_u64 :: "(64 word, 64 word) RR \<Rightarrow> 64 word"
where
  "min_u64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.If ((<) a b) a b))"

definition
  min_u32 :: "(32 word, 32 word) RR \<Rightarrow> 32 word"
where
  "min_u32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.If ((<) a b) a b))"

definition
  max_u64 :: "(64 word, 64 word) RR \<Rightarrow> 64 word"
where
  "max_u64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.If ((<) a b) b a))"

definition
  max_u32 :: "(32 word, 32 word) RR \<Rightarrow> 32 word"
where
  "max_u32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.If ((<) a b) b a))"

definition
  in_range_u32 :: "(32 word, 32 word, 32 word) WordArrayFindSubP \<Rightarrow> bool"
where
  "in_range_u32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 WordArrayFindSubP.p1\<^sub>f) (\<lambda>(needle,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 WordArrayFindSubP.p2\<^sub>f) (\<lambda>(from\<^sub>r,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 WordArrayFindSubP.p3\<^sub>f) (\<lambda>(to,ds\<^sub>3). HOL.If ((>=) needle from\<^sub>r \<and> (<) needle to) True False)))"

definition
  fst :: "('a, 'b) RR \<Rightarrow> 'a"
where
  "fst ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 RR.p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>4. a)))"

definition
  first :: "('a \<Rightarrow> 'a', ('a, 'b) RR) RR \<Rightarrow> ('a', 'b) RR"
where
  "first ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(f,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 RR.p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>5). RR.make (f a) b))))"

definition
  drop :: "'a \<Rightarrow> unit"
where
  "drop ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. ())"

definition
  cogent_low_16_bits :: "32 word \<Rightarrow> 16 word"
where
  "cogent_low_16_bits ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. u32_to_u16 ((AND) x (65535 :: 32 word)))"

definition
  cogent_high_16_bits :: "32 word \<Rightarrow> 16 word"
where
  "cogent_high_16_bits ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. u32_to_u16 (checked_shift shiftr ((AND) x (4294901760 :: 32 word)) (16 :: 32 word)))"

definition
  align64 :: "(64 word, 64 word) RR \<Rightarrow> 64 word"
where
  "align64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(x,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(powof2,ds\<^sub>2). (AND) ((+) x ((-) powof2 (1 :: 64 word))) (NOT ((-) powof2 (1 :: 64 word)))))"

definition
  align32 :: "(32 word, 32 word) RR \<Rightarrow> 32 word"
where
  "align32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(x,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(powof2,ds\<^sub>2). (AND) ((+) x ((-) powof2 (1 :: 32 word))) (NOT ((-) powof2 (1 :: 32 word)))))"

definition
  wordarray_get_u32 :: "(32 word WordArray, 32 word) RR \<Rightarrow> 32 word"
where
  "wordarray_get_u32 ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. wordarray_get x)"

definition
  wordarray_length_u32 :: "32 word WordArray \<Rightarrow> 32 word"
where
  "wordarray_length_u32 ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. wordarray_length x)"

definition
  wordarray_put2_u32 :: "(32 word WordArray, 32 word, 32 word) WordArrayPutP \<Rightarrow> 32 word WordArray"
where
  "wordarray_put2_u32 ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. wordarray_put2 x)"

definition
  wordarray_free' :: "( SysState, 'a WordArray) T0 \<Rightarrow>  SysState"
where
  "wordarray_free' ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 T0.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 T0.obj\<^sub>f) (\<lambda>(obj,ds\<^sub>1). wordarray_free (RR.make ex obj)))"

definition
  error :: "'b \<Rightarrow> ('b, 'a) R"
where
  "error ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>b. (R.Error b :: ('b, 'a) R))"

definition
  safe_add32 :: "(32 word, 32 word) RR \<Rightarrow> (unit, 32 word) R"
where
  "safe_add32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((+) a b) (\<lambda>r. HOL.If ((<) r a \<or> (<) r b) (R.Error () :: (unit, 32 word) R) (R.Success r :: (unit, 32 word) R))))"

definition
  safe_add64 :: "(64 word, 64 word) RR \<Rightarrow> (unit, 64 word) R"
where
  "safe_add64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((+) a b) (\<lambda>r. HOL.If ((<) r a \<or> (<) r b) (R.Error () :: (unit, 64 word) R) (R.Success r :: (unit, 64 word) R))))"

definition
  safe_sub32 :: "(32 word, 32 word) RR \<Rightarrow> (unit, 32 word) R"
where
  "safe_sub32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((-) a b) (\<lambda>r. HOL.If ((>) r a) (R.Error () :: (unit, 32 word) R) (R.Success r :: (unit, 32 word) R))))"

definition
  safe_sub64 :: "(64 word, 64 word) RR \<Rightarrow> (unit, 64 word) R"
where
  "safe_sub64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((-) a b) (\<lambda>r. HOL.If ((>) r a) (R.Error () :: (unit, 64 word) R) (R.Success r :: (unit, 64 word) R))))"

definition
  success :: "'a \<Rightarrow> ('b, 'a) R"
where
  "success ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>a. (R.Success a :: ('b, 'a) R))"

definition
  wordarray_clone :: "( SysState, 'a WordArray) RR \<Rightarrow> ( SysState, ( SysState, 'a WordArray) RR) R"
where
  "wordarray_clone ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(src,ds\<^sub>2). HOL.Let (wordarray_length src) (\<lambda>size. Let\<^sub>d\<^sub>s (wordarray_create (RR.make ex size)) (\<lambda>ds\<^sub>3. case_R (\<lambda>ex. (R.Error ex :: ( SysState, ( SysState, 'a WordArray) RR) R)) (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 RR.p1\<^sub>f) (\<lambda>(ex,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 RR.p2\<^sub>f) (\<lambda>(dest,ds\<^sub>7). (R.Success (RR.make ex (wordarray_copy (WordArrayCopyP.make dest src (0 :: 32 word) (0 :: 32 word) size))) :: ( SysState, ( SysState, 'a WordArray) RR) R)))) ds\<^sub>3))))"

definition
  wordarray_get_bounded :: "('a WordArray, 32 word) RR \<Rightarrow> (unit, 'a) R"
where
  "wordarray_get_bounded ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(arr,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(idx,ds\<^sub>2). HOL.If ((<) idx (wordarray_length arr)) (R.Success (wordarray_get (RR.make arr idx)) :: (unit, 'a) R) (R.Error () :: (unit, 'a) R)))"

definition
  optionToResult :: "(unit, 'a) Option \<Rightarrow> (unit, 'a) R"
where
  "optionToResult ds\<^sub>0 \<equiv> case_Option (\<lambda>ds\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>3. (R.Error () :: (unit, 'a) R))) (\<lambda>a. (R.Success a :: (unit, 'a) R)) ds\<^sub>0"

definition
  resultToOption :: "('e, 'a) R \<Rightarrow> (unit, 'a) Option"
where
  "resultToOption ds\<^sub>0 \<equiv> case_R (\<lambda>ds\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>3. (Option.None () :: (unit, 'a) Option))) (\<lambda>a. (Option.Some a :: (unit, 'a) Option)) ds\<^sub>0"

definition
  copy_n :: "('a, 32 word, 'a WordArray) ElemAO \<Rightarrow> ('a, 32 word) RR"
where
  "copy_n ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(elem,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(idx,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(afrm,ds\<^sub>1). RR.make (wordarray_get (RR.make afrm idx)) ((+) idx (1 :: 32 word)))))"

end
