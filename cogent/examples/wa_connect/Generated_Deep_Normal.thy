(*
This file is generated by Cogent

*)

theory Generated_Deep_Normal
imports "Cogent.Cogent"
begin

definition
  abbreviatedType1 :: " Cogent.type"
where
  "abbreviatedType1 \<equiv> TRecord [(''elem'', (TPrim (Num U32), Present)), (''acc'', (TPrim (Num U32), Present)), (''obsv'', (TUnit, Present))] Unboxed"

definition
  abbreviatedType2 :: " Cogent.type"
where
  "abbreviatedType2 \<equiv> TRecord [(''p1'', (TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable undefined), Present)), (''p2'', (TUnit, Present))] Unboxed"

definition
  abbreviatedType3 :: " Cogent.type"
where
  "abbreviatedType3 \<equiv> TRecord [(''p1'', (TPrim (Num U32), Present)), (''p2'', (TUnit, Present))] Unboxed"

definition
  abbreviatedType4 :: " Cogent.type"
where
  "abbreviatedType4 \<equiv> TRecord [(''elem'', (TPrim (Num U32), Present)), (''acc'', (TUnit, Present)), (''obsv'', (TUnit, Present))] Unboxed"

definition
  abbreviatedType5 :: " Cogent.type"
where
  "abbreviatedType5 \<equiv> TRecord [(''p1'', (TVar 0, Present)), (''p2'', (TPrim (Num U32), Present))] Unboxed"

definition
  abbreviatedType6 :: " Cogent.type"
where
  "abbreviatedType6 \<equiv> TRecord [(''elem'', (TVar 0, Present)), (''acc'', (TPrim (Num U32), Present)), (''obsv'', (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), Present))] Unboxed"

definition
  abbreviatedType7 :: " Cogent.type"
where
  "abbreviatedType7 \<equiv> TSum [(''None'', (TUnit, Unchecked)), (''Some'', (TVar 0, Unchecked))]"

definition
  abbreviatedType8 :: " Cogent.type"
where
  "abbreviatedType8 \<equiv> TSum [(''Error'', (TVar 1, Unchecked)), (''Success'', (TVar 0, Unchecked))]"

definition
  abbreviatedType9 :: " Cogent.type"
where
  "abbreviatedType9 \<equiv> TSum [(''Error'', (TUnit, Unchecked)), (''Success'', (TVar 0, Unchecked))]"

definition
  abbreviatedType10 :: " Cogent.type"
where
  "abbreviatedType10 \<equiv> TRecord [(''p1'', (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), Present)), (''p2'', (TPrim (Num U32), Present))] Unboxed"

definition
  abbreviatedType11 :: " Cogent.type"
where
  "abbreviatedType11 \<equiv> TSum [(''Error'', (TCon ''SysState'' [] (Boxed Writable undefined), Unchecked)), (''Success'', (TRecord [(''p1'', (TCon ''SysState'' [] (Boxed Writable undefined), Present)), (''p2'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present))] Unboxed, Unchecked))]"

definition
  abbreviatedType12 :: " Cogent.type"
where
  "abbreviatedType12 \<equiv> TRecord [(''p1'', (TCon ''SysState'' [] (Boxed Writable undefined), Present)), (''p2'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present))] Unboxed"

definition
  abbreviatedType13 :: " Cogent.type"
where
  "abbreviatedType13 \<equiv> TRecord [(''p1'', (TCon ''SysState'' [] (Boxed Writable undefined), Present)), (''p2'', (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), Present))] Unboxed"

definition
  abbreviatedType14 :: " Cogent.type"
where
  "abbreviatedType14 \<equiv> TSum [(''Error'', (TUnit, Unchecked)), (''Success'', (TPrim (Num U64), Unchecked))]"

definition
  abbreviatedType15 :: " Cogent.type"
where
  "abbreviatedType15 \<equiv> TRecord [(''p1'', (TPrim (Num U64), Present)), (''p2'', (TPrim (Num U64), Present))] Unboxed"

definition
  abbreviatedType16 :: " Cogent.type"
where
  "abbreviatedType16 \<equiv> TSum [(''Error'', (TUnit, Unchecked)), (''Success'', (TPrim (Num U32), Unchecked))]"

definition
  abbreviatedType17 :: " Cogent.type"
where
  "abbreviatedType17 \<equiv> TRecord [(''p1'', (TPrim (Num U32), Present)), (''p2'', (TPrim (Num U32), Present))] Unboxed"

definition
  abbreviatedType18 :: " Cogent.type"
where
  "abbreviatedType18 \<equiv> TRecord [(''ex'', (TCon ''SysState'' [] (Boxed Writable undefined), Present)), (''obj'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present))] Unboxed"

definition
  abbreviatedType19 :: " Cogent.type"
where
  "abbreviatedType19 \<equiv> TRecord [(''arr'', (TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable undefined), Present)), (''idx'', (TPrim (Num U32), Present)), (''val'', (TPrim (Num U32), Present))] Unboxed"

definition
  abbreviatedType20 :: " Cogent.type"
where
  "abbreviatedType20 \<equiv> TRecord [(''p1'', (TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly undefined), Present)), (''p2'', (TPrim (Num U32), Present))] Unboxed"

definition
  abbreviatedType21 :: " Cogent.type"
where
  "abbreviatedType21 \<equiv> TRecord [(''p1'', (TVar 2, Present)), (''p2'', (TVar 1, Present))] Unboxed"

definition
  abbreviatedType22 :: " Cogent.type"
where
  "abbreviatedType22 \<equiv> TRecord [(''p1'', (TFun (TVar 0) (TVar 2), Present)), (''p2'', (TRecord [(''p1'', (TVar 0, Present)), (''p2'', (TVar 1, Present))] Unboxed, Present))] Unboxed"

definition
  abbreviatedType23 :: " Cogent.type"
where
  "abbreviatedType23 \<equiv> TRecord [(''p1'', (TVar 0, Present)), (''p2'', (TVar 1, Present))] Unboxed"

definition
  abbreviatedType24 :: " Cogent.type"
where
  "abbreviatedType24 \<equiv> TRecord [(''p1'', (TPrim (Num U32), Present)), (''p2'', (TPrim (Num U32), Present)), (''p3'', (TPrim (Num U32), Present))] Unboxed"

definition
  abbreviatedType25 :: " Cogent.type"
where
  "abbreviatedType25 \<equiv> TRecord [(''p1'', (TVar 0, Present)), (''p2'', (TVar 2, Present))] Unboxed"

definition
  abbreviatedType26 :: " Cogent.type"
where
  "abbreviatedType26 \<equiv> TRecord [(''p1'', (TFun (TVar 1) (TVar 2), Present)), (''p2'', (abbreviatedType23, Present))] Unboxed"

lemmas abbreviated_type_defs =
  abbreviatedType16_def
  abbreviatedType14_def
  abbreviatedType9_def
  abbreviatedType8_def
  abbreviatedType11_def
  abbreviatedType7_def
  abbreviatedType19_def
  abbreviatedType4_def
  abbreviatedType1_def
  abbreviatedType6_def
  abbreviatedType18_def
  abbreviatedType3_def
  abbreviatedType17_def
  abbreviatedType24_def
  abbreviatedType15_def
  abbreviatedType5_def
  abbreviatedType23_def
  abbreviatedType25_def
  abbreviatedType21_def
  abbreviatedType22_def
  abbreviatedType26_def
  abbreviatedType12_def
  abbreviatedType13_def
  abbreviatedType20_def
  abbreviatedType2_def
  abbreviatedType10_def

definition
  u64_to_u32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "u64_to_u32_type \<equiv> ([], (TPrim (Num U64), TPrim (Num U32)))"

definition
  u64_to_u16_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "u64_to_u16_type \<equiv> ([], (TPrim (Num U64), TPrim (Num U16)))"

definition
  u32_to_u8_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "u32_to_u8_type \<equiv> ([], (TPrim (Num U32), TPrim (Num U8)))"

definition
  u32_to_u16_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "u32_to_u16_type \<equiv> ([], (TPrim (Num U32), TPrim (Num U16)))"

definition
  u16_to_u8_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "u16_to_u8_type \<equiv> ([], (TPrim (Num U16), TPrim (Num U8)))"

definition
  random_u32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "random_u32_type \<equiv> ([], (TUnit, TPrim (Num U32)))"

definition
  wordarray_cmp_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_cmp_type \<equiv> ([], (TRecord [(''p1'', (TCon ''WordArray'' [TPrim (Num U8)] (Boxed ReadOnly undefined), Present)), (''p2'', (TCon ''WordArray'' [TPrim (Num U8)] (Boxed ReadOnly undefined), Present))] Unboxed, TPrim Bool))"

definition
  wordarray_copy_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_copy_type \<equiv> ([{E, S, D}], (TRecord [(''p1'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''p2'', (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), Present)), (''p3'', (TPrim (Num U32), Present)), (''p4'', (TPrim (Num U32), Present)), (''p5'', (TPrim (Num U32), Present))] Unboxed, TCon ''WordArray'' [TVar 0] (Boxed Writable undefined)))"

definition
  wordarray_fold'_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_fold'_type \<equiv> ([{E, S, D}, {}, {S, D}], (TRecord [(''p1'', (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), Present)), (''p2'', (TFun (TRecord [(''p1'', (TVar 1, Present)), (''p2'', (TVar 2, Present)), (''p3'', (TVar 0, Present))] Unboxed) (TVar 1), Present)), (''p3'', (TVar 1, Present)), (''p4'', (TVar 2, Present))] Unboxed, TVar 1))"

definition
  wordarray_get_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_get_type \<equiv> ([{E, S, D}], (abbreviatedType10, TVar 0))"

definition
  wordarray_length_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_length_type \<equiv> ([{E, S, D}], (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), TPrim (Num U32)))"

definition
  wordarray_map'_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_map'_type \<equiv> ([{E, S, D}, {}, {S, D}], (TRecord [(''p1'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''p2'', (TFun (TRecord [(''p1'', (TVar 1, Present)), (''p2'', (TVar 2, Present)), (''p3'', (TVar 0, Present))] Unboxed) (TRecord [(''p1'', (TVar 1, Present)), (''p2'', (TVar 0, Present))] Unboxed), Present)), (''p3'', (TVar 1, Present)), (''p4'', (TVar 2, Present))] Unboxed, TRecord [(''p1'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''p2'', (TVar 1, Present))] Unboxed))"

definition
  wordarray_map_simple_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_map_simple_type \<equiv> ([{E, S, D}], (TRecord [(''p1'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''p2'', (TFun (TVar 0) (TVar 0), Present))] Unboxed, TCon ''WordArray'' [TVar 0] (Boxed Writable undefined)))"

definition
  wordarray_put2_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_put2_type \<equiv> ([{E, S, D}], (TRecord [(''arr'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''idx'', (TPrim (Num U32), Present)), (''val'', (TVar 0, Present))] Unboxed, TCon ''WordArray'' [TVar 0] (Boxed Writable undefined)))"

definition
  wordarray_set_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_set_type \<equiv> ([{E, S, D}], (TRecord [(''p1'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''p2'', (TPrim (Num U32), Present)), (''p3'', (TPrim (Num U32), Present)), (''p4'', (TVar 0, Present))] Unboxed, TCon ''WordArray'' [TVar 0] (Boxed Writable undefined)))"

definition
  wordarray_split_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_split_type \<equiv> ([{E, S, D}], (TRecord [(''p1'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''p2'', (TPrim (Num U32), Present))] Unboxed, TRecord [(''p1'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''p2'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present))] Unboxed))"

definition
  wordarray_take_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_take_type \<equiv> ([{E, S, D}], (abbreviatedType10, TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined)))"

definition
  wordarray_u8_as_u32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_u8_as_u32_type \<equiv> ([], (TCon ''WordArray'' [TPrim (Num U8)] (Boxed ReadOnly undefined), TPrim (Num U32)))"

definition
  wordarray_map_view_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_map_view_type \<equiv> ([{E, S, D}], (TRecord [(''p1'', (TCon ''View'' [TCon ''WordArray'' [TVar 0] (Boxed Writable undefined)] Unboxed, Present)), (''p2'', (TFun (TVar 0) (TVar 0), Present))] Unboxed, TCon ''View'' [TCon ''WordArray'' [TVar 0] (Boxed Writable undefined)] Unboxed))"

definition
  wordarray_unview_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_unview_type \<equiv> ([{E, S, D}], (TCon ''View'' [TCon ''WordArray'' [TVar 0] (Boxed Writable undefined)] Unboxed, TCon ''WordArray'' [TVar 0] (Boxed Writable undefined)))"

definition
  wordarray_view_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_view_type \<equiv> ([{E, S, D}], (TRecord [(''p1'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''p2'', (TPrim (Num U32), Present)), (''p3'', (TPrim (Num U32), Present)), (''p4'', (TPrim (Num U32), Present))] Unboxed, TCon ''View'' [TCon ''WordArray'' [TVar 0] (Boxed Writable undefined)] Unboxed))"

definition
  wordarray_free_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_free_type \<equiv> ([{E, S, D}], (abbreviatedType12, TCon ''SysState'' [] (Boxed Writable undefined)))"

definition
  seq32_simple_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "seq32_simple_type \<equiv> ([{}], (TRecord [(''frm'', (TPrim (Num U32), Present)), (''to'', (TPrim (Num U32), Present)), (''step'', (TPrim (Num U32), Present)), (''f'', (TFun (TVar 0) (TVar 0), Present)), (''acc'', (TVar 0, Present))] Unboxed, TVar 0))"

definition
  wordarray_clone_rr_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_clone_rr_type \<equiv> ([{E, S, D}, {E, S, D}], (abbreviatedType13, TRecord [(''p1'', (TCon ''SysState'' [] (Boxed Writable undefined), Present)), (''p2'', (TSum [(''Error'', (TUnit, Unchecked)), (''Success'', (TCon ''WordArray'' [TVar 1] (Boxed Writable undefined), Unchecked))], Present))] Unboxed))"

definition
  wordarray_slice_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_slice_type \<equiv> ([{E, S, D}], (TRecord [(''p1'', (TCon ''SysState'' [] (Boxed Writable undefined), Present)), (''p2'', (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), Present)), (''p3'', (TPrim (Num U32), Present)), (''p4'', (TPrim (Num U32), Present))] Unboxed, TRecord [(''p1'', (TCon ''SysState'' [] (Boxed Writable undefined), Present)), (''p2'', (TSum [(''Error'', (TUnit, Unchecked)), (''Success'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Unchecked))], Present))] Unboxed))"

definition
  wordarray_create_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_create_type \<equiv> ([{E, S, D}], (TRecord [(''p1'', (TCon ''SysState'' [] (Boxed Writable undefined), Present)), (''p2'', (TPrim (Num U32), Present))] Unboxed, TSum [(''Error'', (TCon ''SysState'' [] (Boxed Writable undefined), Unchecked)), (''Success'', (abbreviatedType12, Unchecked))]))"

definition
  wordarray_create_nz_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_create_nz_type \<equiv> ([{E, S, D}], (TRecord [(''p1'', (TCon ''SysState'' [] (Boxed Writable undefined), Present)), (''p2'', (TPrim (Num U32), Present))] Unboxed, TSum [(''Error'', (TCon ''SysState'' [] (Boxed Writable undefined), Unchecked)), (''Success'', (abbreviatedType12, Unchecked))]))"

definition
  wordarray_put_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_put_type \<equiv> ([{E, S, D}], (TRecord [(''arr'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''idx'', (TPrim (Num U32), Present)), (''val'', (TVar 0, Present))] Unboxed, TSum [(''Error'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Unchecked)), (''Success'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Unchecked))]))"

definition
  seq32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "seq32_type \<equiv> ([{}, {}, {}], (TRecord [(''frm'', (TPrim (Num U32), Present)), (''to'', (TPrim (Num U32), Present)), (''step'', (TPrim (Num U32), Present)), (''f'', (TFun (TRecord [(''acc'', (TVar 0, Present)), (''obsv'', (TVarBang 1, Present)), (''idx'', (TPrim (Num U32), Present))] Unboxed) (TRecord [(''p1'', (TVar 0, Present)), (''p2'', (TSum [(''Break'', (TVar 2, Unchecked)), (''Iterate'', (TUnit, Unchecked))], Present))] Unboxed), Present)), (''acc'', (TVar 0, Present)), (''obsv'', (TVarBang 1, Present))] Unboxed, TRecord [(''p1'', (TVar 0, Present)), (''p2'', (TSum [(''Break'', (TVar 2, Unchecked)), (''Iterate'', (TUnit, Unchecked))], Present))] Unboxed))"

definition
  seq32_rev_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "seq32_rev_type \<equiv> ([{}, {}, {}], (TRecord [(''frm'', (TPrim (Num U32), Present)), (''to'', (TPrim (Num U32), Present)), (''step'', (TPrim (Num U32), Present)), (''f'', (TFun (TRecord [(''acc'', (TVar 0, Present)), (''obsv'', (TVarBang 1, Present)), (''idx'', (TPrim (Num U32), Present))] Unboxed) (TRecord [(''p1'', (TVar 0, Present)), (''p2'', (TSum [(''Break'', (TVar 2, Unchecked)), (''Iterate'', (TUnit, Unchecked))], Present))] Unboxed), Present)), (''acc'', (TVar 0, Present)), (''obsv'', (TVarBang 1, Present))] Unboxed, TRecord [(''p1'', (TVar 0, Present)), (''p2'', (TSum [(''Break'', (TVar 2, Unchecked)), (''Iterate'', (TUnit, Unchecked))], Present))] Unboxed))"

definition
  seq32_stepf_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "seq32_stepf_type \<equiv> ([{}, {}, {}], (TRecord [(''frm'', (TPrim (Num U32), Present)), (''to'', (TPrim (Num U32), Present)), (''stepf'', (TFun (TPrim (Num U32)) (TPrim (Num U32)), Present)), (''f'', (TFun (TRecord [(''acc'', (TVar 0, Present)), (''obsv'', (TVarBang 1, Present)), (''idx'', (TPrim (Num U32), Present))] Unboxed) (TRecord [(''p1'', (TVar 0, Present)), (''p2'', (TSum [(''Break'', (TVar 2, Unchecked)), (''Iterate'', (TUnit, Unchecked))], Present))] Unboxed), Present)), (''acc'', (TVar 0, Present)), (''obsv'', (TVarBang 1, Present))] Unboxed, TRecord [(''p1'', (TVar 0, Present)), (''p2'', (TSum [(''Break'', (TVar 2, Unchecked)), (''Iterate'', (TUnit, Unchecked))], Present))] Unboxed))"

definition
  seq64_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "seq64_type \<equiv> ([{}, {}, {}], (TRecord [(''frm'', (TPrim (Num U64), Present)), (''to'', (TPrim (Num U64), Present)), (''step'', (TPrim (Num U64), Present)), (''f'', (TFun (TRecord [(''acc'', (TVar 0, Present)), (''obsv'', (TVarBang 1, Present)), (''idx'', (TPrim (Num U64), Present))] Unboxed) (TRecord [(''p1'', (TVar 0, Present)), (''p2'', (TSum [(''Break'', (TVar 2, Unchecked)), (''Iterate'', (TUnit, Unchecked))], Present))] Unboxed), Present)), (''acc'', (TVar 0, Present)), (''obsv'', (TVarBang 1, Present))] Unboxed, TRecord [(''p1'', (TVar 0, Present)), (''p2'', (TSum [(''Break'', (TVar 2, Unchecked)), (''Iterate'', (TUnit, Unchecked))], Present))] Unboxed))"

definition
  wordarray_findsub_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_findsub_type \<equiv> ([{E, S, D}], (TRecord [(''p1'', (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), Present)), (''p2'', (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), Present)), (''p3'', (TPrim (Num U32), Present))] Unboxed, TSum [(''Found'', (TPrim (Num U32), Unchecked)), (''NotFound'', (TUnit, Unchecked))]))"

definition
  wordarray_fold_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_fold_type \<equiv> ([{E, S, D}, {}, {}, {}], (TRecord [(''arr'', (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), Present)), (''frm'', (TPrim (Num U32), Present)), (''to'', (TPrim (Num U32), Present)), (''f'', (TFun (TRecord [(''elem'', (TVar 0, Present)), (''acc'', (TVar 1, Present)), (''obsv'', (TVarBang 2, Present))] Unboxed) (TSum [(''Break'', (TVar 3, Unchecked)), (''Iterate'', (TVar 1, Unchecked))]), Present)), (''acc'', (TVar 1, Present)), (''obsv'', (TVarBang 2, Present))] Unboxed, TSum [(''Break'', (TVar 3, Unchecked)), (''Iterate'', (TVar 1, Unchecked))]))"

definition
  wordarray_fold_no_break_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_fold_no_break_type \<equiv> ([{E, S, D}, {}, {}], (TRecord [(''arr'', (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), Present)), (''frm'', (TPrim (Num U32), Present)), (''to'', (TPrim (Num U32), Present)), (''f'', (TFun (TRecord [(''elem'', (TVar 0, Present)), (''acc'', (TVar 1, Present)), (''obsv'', (TVarBang 2, Present))] Unboxed) (TVar 1), Present)), (''acc'', (TVar 1, Present)), (''obsv'', (TVarBang 2, Present))] Unboxed, TVar 1))"

definition
  wordarray_map_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_map_type \<equiv> ([{E, S, D}, {}, {}, {}], (TRecord [(''arr'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''frm'', (TPrim (Num U32), Present)), (''to'', (TPrim (Num U32), Present)), (''f'', (TFun (TRecord [(''elem'', (TVar 0, Present)), (''acc'', (TVar 1, Present)), (''obsv'', (TVarBang 2, Present))] Unboxed) (TRecord [(''p1'', (abbreviatedType23, Present)), (''p2'', (TSum [(''Break'', (TVar 3, Unchecked)), (''Iterate'', (TUnit, Unchecked))], Present))] Unboxed), Present)), (''acc'', (TVar 1, Present)), (''obsv'', (TVar 2, Present))] Unboxed, TRecord [(''p1'', (TRecord [(''p1'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''p2'', (TVar 1, Present))] Unboxed, Present)), (''p2'', (TSum [(''Break'', (TVar 3, Unchecked)), (''Iterate'', (TUnit, Unchecked))], Present))] Unboxed))"

definition
  wordarray_map_no_break_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_map_no_break_type \<equiv> ([{E, S, D}, {}, {}], (TRecord [(''arr'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''frm'', (TPrim (Num U32), Present)), (''to'', (TPrim (Num U32), Present)), (''f'', (TFun (TRecord [(''elem'', (TVar 0, Present)), (''acc'', (TVar 1, Present)), (''obsv'', (TVarBang 2, Present))] Unboxed) abbreviatedType23, Present)), (''acc'', (TVar 1, Present)), (''obsv'', (TVar 2, Present))] Unboxed, TRecord [(''p1'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''p2'', (TVar 1, Present))] Unboxed))"

definition
  wordarray_print_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_print_type \<equiv> ([], (TCon ''WordArray'' [TPrim (Num U8)] (Boxed ReadOnly undefined), TUnit))"

definition
  wordarray_modify_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_modify_type \<equiv> ([{E, S, D}, {}, {}], (TRecord [(''arr'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''idx'', (TPrim (Num U32), Present)), (''f'', (TFun (TRecord [(''elem'', (TVar 0, Present)), (''acc'', (TVar 1, Present)), (''obsv'', (TVarBang 2, Present))] Unboxed) (TRecord [(''elem'', (TVar 0, Present)), (''acc'', (TVar 1, Present))] Unboxed), Present)), (''acc'', (TVar 1, Present)), (''obsv'', (TVarBang 2, Present))] Unboxed, TRecord [(''arr'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''acc'', (TVar 1, Present))] Unboxed))"

definition
  snd_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "snd_type \<equiv> ([{D}, {}], (abbreviatedType23, TVar 1))"

definition
  snd :: "string Cogent.expr"
where
  "snd \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (Var 2) (Var 1)))"

definition
  second_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "second_type \<equiv> ([{}, {}, {}], (abbreviatedType26, abbreviatedType25))"

definition
  second :: "string Cogent.expr"
where
  "second \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 0) 0 (Take (Var 1) 1 (Let (App (Var 6) (Var 0)) (Struct [TVar 0, TVar 2] [Var 3, Var 0])))))"

definition
  min_u64_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "min_u64_type \<equiv> ([], (abbreviatedType15, TPrim (Num U64)))"

definition
  min_u64 :: "string Cogent.expr"
where
  "min_u64 \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (Prim (Lt U64) [Var 2, Var 0]) (If (Var 0) (Var 3) (Var 1))))"

definition
  min_u32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "min_u32_type \<equiv> ([], (abbreviatedType17, TPrim (Num U32)))"

definition
  min_u32 :: "string Cogent.expr"
where
  "min_u32 \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (Prim (Lt U32) [Var 2, Var 0]) (If (Var 0) (Var 3) (Var 1))))"

definition
  max_u64_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "max_u64_type \<equiv> ([], (abbreviatedType15, TPrim (Num U64)))"

definition
  max_u64 :: "string Cogent.expr"
where
  "max_u64 \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (Prim (Lt U64) [Var 2, Var 0]) (If (Var 0) (Var 1) (Var 3))))"

definition
  max_u32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "max_u32_type \<equiv> ([], (abbreviatedType17, TPrim (Num U32)))"

definition
  max_u32 :: "string Cogent.expr"
where
  "max_u32 \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (Prim (Lt U32) [Var 2, Var 0]) (If (Var 0) (Var 1) (Var 3))))"

definition
  in_range_u32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "in_range_u32_type \<equiv> ([], (abbreviatedType24, TPrim Bool))"

definition
  in_range_u32 :: "string Cogent.expr"
where
  "in_range_u32 \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 1) 2 (Let (Prim (Ge U32) [Var 4, Var 2]) (Let (Prim (Lt U32) [Var 5, Var 1]) (Let (Prim Cogent.And [Var 1, Var 0]) (If (Var 0) (Lit (LBool True)) (Lit (LBool False))))))))"

definition
  fst_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "fst_type \<equiv> ([{}, {D}], (abbreviatedType23, TVar 0))"

definition
  fst :: "string Cogent.expr"
where
  "fst \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (Var 0) (Var 3)))"

definition
  first_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "first_type \<equiv> ([{}, {}, {}], (TRecord [(''p1'', (TFun (TVar 0) (TVar 2), Present)), (''p2'', (abbreviatedType23, Present))] Unboxed, abbreviatedType21))"

definition
  first :: "string Cogent.expr"
where
  "first \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 0) 0 (Take (Var 1) 1 (Let (App (Var 6) (Var 2)) (Struct [TVar 2, TVar 1] [Var 0, Var 1])))))"

definition
  drop_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "drop_type \<equiv> ([{D}], (TVar 0, TUnit))"

definition
  drop :: "string Cogent.expr"
where
  "drop \<equiv> Let (Var 0) Unit"

definition
  cogent_low_16_bits_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "cogent_low_16_bits_type \<equiv> ([], (TPrim (Num U32), TPrim (Num U16)))"

definition
  cogent_low_16_bits :: "string Cogent.expr"
where
  "cogent_low_16_bits \<equiv> Let (Var 0) (Let (Lit (LU32 65535)) (Let (Prim (BitAnd U32) [Var 1, Var 0]) (App (AFun ''u32_to_u16'' []) (Var 0))))"

definition
  cogent_high_16_bits_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "cogent_high_16_bits_type \<equiv> ([], (TPrim (Num U32), TPrim (Num U16)))"

definition
  cogent_high_16_bits :: "string Cogent.expr"
where
  "cogent_high_16_bits \<equiv> Let (Var 0) (Let (Lit (LU32 4294901760)) (Let (Prim (BitAnd U32) [Var 1, Var 0]) (Let (Lit (LU32 16)) (Let (Prim (RShift U32) [Var 1, Var 0]) (App (AFun ''u32_to_u16'' []) (Var 0))))))"

definition
  align64_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "align64_type \<equiv> ([], (abbreviatedType15, TPrim (Num U64)))"

definition
  align64 :: "string Cogent.expr"
where
  "align64 \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (Lit (LU64 1)) (Let (Prim (Minus U64) [Var 1, Var 0]) (Let (Prim (Plus U64) [Var 4, Var 0]) (Let (Lit (LU64 1)) (Let (Prim (Minus U64) [Var 4, Var 0]) (Let (Prim (Complement U64) [Var 0]) (Prim (BitAnd U64) [Var 3, Var 0]))))))))"

definition
  align32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "align32_type \<equiv> ([], (abbreviatedType17, TPrim (Num U32)))"

definition
  align32 :: "string Cogent.expr"
where
  "align32 \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (Lit (LU32 1)) (Let (Prim (Minus U32) [Var 1, Var 0]) (Let (Prim (Plus U32) [Var 4, Var 0]) (Let (Lit (LU32 1)) (Let (Prim (Minus U32) [Var 4, Var 0]) (Let (Prim (Complement U32) [Var 0]) (Prim (BitAnd U32) [Var 3, Var 0]))))))))"

definition
  wordarray_get_u32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_get_u32_type \<equiv> ([], (abbreviatedType20, TPrim (Num U32)))"

definition
  wordarray_get_u32 :: "string Cogent.expr"
where
  "wordarray_get_u32 \<equiv> Let (Var 0) (App (AFun ''wordarray_get'' [TPrim (Num U32)]) (Var 0))"

definition
  wordarray_length_u32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_length_u32_type \<equiv> ([], (TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly undefined), TPrim (Num U32)))"

definition
  wordarray_length_u32 :: "string Cogent.expr"
where
  "wordarray_length_u32 \<equiv> Let (Var 0) (App (AFun ''wordarray_length'' [TPrim (Num U32)]) (Var 0))"

definition
  wordarray_put2_u32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_put2_u32_type \<equiv> ([], (abbreviatedType19, TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable undefined)))"

definition
  wordarray_put2_u32 :: "string Cogent.expr"
where
  "wordarray_put2_u32 \<equiv> Let (Var 0) (App (AFun ''wordarray_put2'' [TPrim (Num U32)]) (Var 0))"

definition
  wordarray_free'_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_free'_type \<equiv> ([{E, S, D}], (abbreviatedType18, TCon ''SysState'' [] (Boxed Writable undefined)))"

definition
  wordarray_free' :: "string Cogent.expr"
where
  "wordarray_free' \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (Struct [TCon ''SysState'' [] (Boxed Writable undefined), TCon ''WordArray'' [TVar 0] (Boxed Writable undefined)] [Var 2, Var 0]) (App (AFun ''wordarray_free'' [TVar 0]) (Var 0))))"

definition
  error_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "error_type \<equiv> ([{}, {}], (TVar 1, abbreviatedType8))"

definition
  error :: "string Cogent.expr"
where
  "error \<equiv> Let (Var 0) (Let (Con [(''Error'', (TVar 1, Unchecked)), (''Success'', (TVar 0, Checked))] ''Error'' (Var 0)) (Promote abbreviatedType8 (Var 0)))"

definition
  safe_add32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "safe_add32_type \<equiv> ([], (abbreviatedType17, abbreviatedType16))"

definition
  safe_add32 :: "string Cogent.expr"
where
  "safe_add32 \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (Prim (Plus U32) [Var 2, Var 0]) (Let (Prim (Lt U32) [Var 0, Var 3]) (Let (Prim (Lt U32) [Var 1, Var 2]) (Let (Prim Cogent.Or [Var 1, Var 0]) (If (Var 0) (Let Unit (Let (Con [(''Error'', (TUnit, Unchecked)), (''Success'', (TPrim (Num U32), Checked))] ''Error'' (Var 0)) (Promote abbreviatedType16 (Var 0)))) (Let (Con [(''Error'', (TUnit, Checked)), (''Success'', (TPrim (Num U32), Unchecked))] ''Success'' (Var 3)) (Promote abbreviatedType16 (Var 0)))))))))"

definition
  safe_add64_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "safe_add64_type \<equiv> ([], (abbreviatedType15, abbreviatedType14))"

definition
  safe_add64 :: "string Cogent.expr"
where
  "safe_add64 \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (Prim (Plus U64) [Var 2, Var 0]) (Let (Prim (Lt U64) [Var 0, Var 3]) (Let (Prim (Lt U64) [Var 1, Var 2]) (Let (Prim Cogent.Or [Var 1, Var 0]) (If (Var 0) (Let Unit (Let (Con [(''Error'', (TUnit, Unchecked)), (''Success'', (TPrim (Num U64), Checked))] ''Error'' (Var 0)) (Promote abbreviatedType14 (Var 0)))) (Let (Con [(''Error'', (TUnit, Checked)), (''Success'', (TPrim (Num U64), Unchecked))] ''Success'' (Var 3)) (Promote abbreviatedType14 (Var 0)))))))))"

definition
  safe_sub32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "safe_sub32_type \<equiv> ([], (abbreviatedType17, abbreviatedType16))"

definition
  safe_sub32 :: "string Cogent.expr"
where
  "safe_sub32 \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (Prim (Minus U32) [Var 2, Var 0]) (Let (Prim (Gt U32) [Var 0, Var 3]) (If (Var 0) (Let Unit (Let (Con [(''Error'', (TUnit, Unchecked)), (''Success'', (TPrim (Num U32), Checked))] ''Error'' (Var 0)) (Promote abbreviatedType16 (Var 0)))) (Let (Con [(''Error'', (TUnit, Checked)), (''Success'', (TPrim (Num U32), Unchecked))] ''Success'' (Var 1)) (Promote abbreviatedType16 (Var 0)))))))"

definition
  safe_sub64_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "safe_sub64_type \<equiv> ([], (abbreviatedType15, abbreviatedType14))"

definition
  safe_sub64 :: "string Cogent.expr"
where
  "safe_sub64 \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (Prim (Minus U64) [Var 2, Var 0]) (Let (Prim (Gt U64) [Var 0, Var 3]) (If (Var 0) (Let Unit (Let (Con [(''Error'', (TUnit, Unchecked)), (''Success'', (TPrim (Num U64), Checked))] ''Error'' (Var 0)) (Promote abbreviatedType14 (Var 0)))) (Let (Con [(''Error'', (TUnit, Checked)), (''Success'', (TPrim (Num U64), Unchecked))] ''Success'' (Var 1)) (Promote abbreviatedType14 (Var 0)))))))"

definition
  success_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "success_type \<equiv> ([{}, {}], (TVar 0, abbreviatedType8))"

definition
  success :: "string Cogent.expr"
where
  "success \<equiv> Let (Var 0) (Let (Con [(''Error'', (TVar 1, Checked)), (''Success'', (TVar 0, Unchecked))] ''Success'' (Var 0)) (Promote abbreviatedType8 (Var 0)))"

definition
  wordarray_clone_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_clone_type \<equiv> ([{E, S, D}], (abbreviatedType13, TSum [(''Error'', (TCon ''SysState'' [] (Boxed Writable undefined), Unchecked)), (''Success'', (abbreviatedType12, Unchecked))]))"

definition
  wordarray_clone :: "string Cogent.expr"
where
  "wordarray_clone \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (App (AFun ''wordarray_length'' [TVar 0]) (Var 0)) (Let (Struct [TCon ''SysState'' [] (Boxed Writable undefined), TPrim (Num U32)] [Var 3, Var 0]) (Let (App (AFun ''wordarray_create'' [TVar 0]) (Var 0)) (Case (Var 0) ''Error'' (Let (Con [(''Error'', (TCon ''SysState'' [] (Boxed Writable undefined), Unchecked)), (''Success'', (abbreviatedType12, Checked))] ''Error'' (Var 0)) (Promote (TSum [(''Error'', (TCon ''SysState'' [] (Boxed Writable undefined), Unchecked)), (''Success'', (abbreviatedType12, Unchecked))]) (Var 0))) (Let (Esac (Var 0) ''Success'') (Take (Var 0) 0 (Take (Var 1) 1 (Let (Lit (LU32 0)) (Let (Lit (LU32 0)) (Let (Struct [TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), TPrim (Num U32), TPrim (Num U32), TPrim (Num U32)] [Var 2, Var 11, Var 1, Var 0, Var 10]) (Let (App (AFun ''wordarray_copy'' [TVar 0]) (Var 0)) (Let (Struct [TCon ''SysState'' [] (Boxed Writable undefined), TCon ''WordArray'' [TVar 0] (Boxed Writable undefined)] [Var 6, Var 0]) (Let (Con [(''Error'', (TCon ''SysState'' [] (Boxed Writable undefined), Checked)), (''Success'', (abbreviatedType12, Unchecked))] ''Success'' (Var 0)) (Promote (TSum [(''Error'', (TCon ''SysState'' [] (Boxed Writable undefined), Unchecked)), (''Success'', (abbreviatedType12, Unchecked))]) (Var 0))))))))))))))))"

definition
  wordarray_get_bounded_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_get_bounded_type \<equiv> ([{E, S, D}], (abbreviatedType10, abbreviatedType9))"

definition
  wordarray_get_bounded :: "string Cogent.expr"
where
  "wordarray_get_bounded \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (App (AFun ''wordarray_length'' [TVar 0]) (Var 2)) (Let (Prim (Lt U32) [Var 1, Var 0]) (If (Var 0) (Let (Struct [TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), TPrim (Num U32)] [Var 4, Var 2]) (Let (App (AFun ''wordarray_get'' [TVar 0]) (Var 0)) (Let (Con [(''Error'', (TUnit, Checked)), (''Success'', (TVar 0, Unchecked))] ''Success'' (Var 0)) (Promote abbreviatedType9 (Var 0))))) (Let Unit (Let (Con [(''Error'', (TUnit, Unchecked)), (''Success'', (TVar 0, Checked))] ''Error'' (Var 0)) (Promote abbreviatedType9 (Var 0))))))))"

definition
  optionToResult_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "optionToResult_type \<equiv> ([{}], (abbreviatedType7, abbreviatedType9))"

definition
  optionToResult :: "string Cogent.expr"
where
  "optionToResult \<equiv> Case (Var 0) ''None'' (Let (Var 0) (Let Unit (Let (Con [(''Error'', (TUnit, Unchecked)), (''Success'', (TVar 0, Checked))] ''Error'' (Var 0)) (Promote abbreviatedType9 (Var 0))))) (Let (Esac (Var 0) ''Some'') (Let (Con [(''Error'', (TUnit, Checked)), (''Success'', (TVar 0, Unchecked))] ''Success'' (Var 0)) (Promote abbreviatedType9 (Var 0))))"

definition
  resultToOption_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "resultToOption_type \<equiv> ([{}, {S, D}], (abbreviatedType8, abbreviatedType7))"

definition
  resultToOption :: "string Cogent.expr"
where
  "resultToOption \<equiv> Case (Var 0) ''Error'' (Let (Var 0) (Let Unit (Let (Con [(''None'', (TUnit, Unchecked)), (''Some'', (TVar 0, Checked))] ''None'' (Var 0)) (Promote abbreviatedType7 (Var 0))))) (Let (Esac (Var 0) ''Success'') (Let (Con [(''None'', (TUnit, Checked)), (''Some'', (TVar 0, Unchecked))] ''Some'' (Var 0)) (Promote abbreviatedType7 (Var 0))))"

definition
  copy_n_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "copy_n_type \<equiv> ([{E, S, D}], (abbreviatedType6, abbreviatedType5))"

definition
  copy_n :: "string Cogent.expr"
where
  "copy_n \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 1) 2 (Let (Struct [TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), TPrim (Num U32)] [Var 0, Var 2]) (Let (App (AFun ''wordarray_get'' [TVar 0]) (Var 0)) (Let (Lit (LU32 1)) (Let (Prim (Plus U32) [Var 5, Var 0]) (Struct [TVar 0, TPrim (Num U32)] [Var 2, Var 0])))))))"

definition
  dec_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "dec_type \<equiv> ([], (abbreviatedType4, abbreviatedType3))"

definition
  dec :: "string Cogent.expr"
where
  "dec \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 1) 2 (Let (Lit (LU32 1)) (Let (Prim (Minus U32) [Var 5, Var 0]) (Struct [TPrim (Num U32), TUnit] [Var 0, Var 4])))))"

definition
  dec_arr_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "dec_arr_type \<equiv> ([], (TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable undefined), abbreviatedType2))"

definition
  dec_arr :: "string Cogent.expr"
where
  "dec_arr \<equiv> Let (Var 0) (LetBang (set [0]) (App (AFun ''wordarray_length'' [TPrim (Num U32)]) (Var 0)) (Let (Lit (LU32 0)) (Let (Fun dec []) (Let Unit (Let Unit (Let (Struct [TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable undefined), TPrim (Num U32), TPrim (Num U32), TFun abbreviatedType4 abbreviatedType3, TUnit, TUnit] [Var 5, Var 3, Var 4, Var 2, Var 1, Var 0]) (App (AFun ''wordarray_map_no_break'' [TPrim (Num U32), TUnit, TUnit]) (Var 0))))))))"

definition
  inc_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "inc_type \<equiv> ([], (abbreviatedType4, abbreviatedType3))"

definition
  inc :: "string Cogent.expr"
where
  "inc \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 1) 2 (Let (Lit (LU32 1)) (Let (Prim (Plus U32) [Var 5, Var 0]) (Struct [TPrim (Num U32), TUnit] [Var 0, Var 4])))))"

definition
  inc_arr_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "inc_arr_type \<equiv> ([], (TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable undefined), abbreviatedType2))"

definition
  inc_arr :: "string Cogent.expr"
where
  "inc_arr \<equiv> Let (Var 0) (LetBang (set [0]) (App (AFun ''wordarray_length'' [TPrim (Num U32)]) (Var 0)) (Let (Lit (LU32 0)) (Let (Fun inc []) (Let Unit (Let Unit (Let (Struct [TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable undefined), TPrim (Num U32), TPrim (Num U32), TFun abbreviatedType4 abbreviatedType3, TUnit, TUnit] [Var 5, Var 3, Var 4, Var 2, Var 1, Var 0]) (App (AFun ''wordarray_map_no_break'' [TPrim (Num U32), TUnit, TUnit]) (Var 0))))))))"

definition
  mul_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "mul_type \<equiv> ([], (abbreviatedType1, TPrim (Num U32)))"

definition
  mul :: "string Cogent.expr"
where
  "mul \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 1) 2 (Prim (Times U32) [Var 4, Var 2])))"

definition
  mul_arr_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "mul_arr_type \<equiv> ([], (TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly undefined), TPrim (Num U32)))"

definition
  mul_arr :: "string Cogent.expr"
where
  "mul_arr \<equiv> Let (Var 0) (Let (App (Fun wordarray_length_u32 []) (Var 0)) (Let (Lit (LU32 0)) (Let (Fun mul []) (Let (Lit (LU32 0)) (Let Unit (Let (Struct [TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly undefined), TPrim (Num U32), TPrim (Num U32), TFun abbreviatedType1 (TPrim (Num U32)), TPrim (Num U32), TUnit] [Var 5, Var 3, Var 4, Var 2, Var 1, Var 0]) (App (AFun ''wordarray_fold_no_break'' [TPrim (Num U32), TPrim (Num U32), TUnit]) (Var 0))))))))"

definition
  sum_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "sum_type \<equiv> ([], (abbreviatedType1, TPrim (Num U32)))"

definition
  sum :: "string Cogent.expr"
where
  "sum \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 1) 2 (Prim (Plus U32) [Var 4, Var 2])))"

definition
  sum_arr_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "sum_arr_type \<equiv> ([], (TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly undefined), TPrim (Num U32)))"

definition
  sum_arr :: "string Cogent.expr"
where
  "sum_arr \<equiv> Let (Var 0) (Let (App (Fun wordarray_length_u32 []) (Var 0)) (Let (Lit (LU32 0)) (Let (Fun sum []) (Let (Lit (LU32 0)) (Let Unit (Let (Struct [TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly undefined), TPrim (Num U32), TPrim (Num U32), TFun abbreviatedType1 (TPrim (Num U32)), TPrim (Num U32), TUnit] [Var 5, Var 3, Var 4, Var 2, Var 1, Var 0]) (App (AFun ''wordarray_fold_no_break'' [TPrim (Num U32), TPrim (Num U32), TUnit]) (Var 0))))))))"

ML \<open>
val Cogent_functions = ["snd", "second", "min_u64", "min_u32", "max_u64", "max_u32", "in_range_u32", "fst", "first", "drop", "cogent_low_16_bits", "cogent_high_16_bits", "align64", "align32", "wordarray_get_u32", "wordarray_length_u32", "wordarray_put2_u32", "wordarray_free'", "error", "safe_add32", "safe_add64", "safe_sub32", "safe_sub64", "success", "wordarray_clone", "wordarray_get_bounded", "optionToResult", "resultToOption", "copy_n", "dec", "dec_arr", "inc", "inc_arr", "mul", "mul_arr", "sum", "sum_arr"]
val Cogent_abstract_functions = ["u64_to_u32", "u64_to_u16", "u32_to_u8", "u32_to_u16", "u16_to_u8", "random_u32", "wordarray_cmp", "wordarray_copy", "wordarray_fold'", "wordarray_get", "wordarray_length", "wordarray_map'", "wordarray_map_simple", "wordarray_put2", "wordarray_set", "wordarray_split", "wordarray_take", "wordarray_u8_as_u32", "wordarray_map_view", "wordarray_unview", "wordarray_view", "wordarray_free", "seq32_simple", "wordarray_clone_rr", "wordarray_slice", "wordarray_create", "wordarray_create_nz", "wordarray_put", "seq32", "seq32_rev", "seq32_stepf", "seq64", "wordarray_findsub", "wordarray_fold", "wordarray_fold_no_break", "wordarray_map", "wordarray_map_no_break", "wordarray_print", "wordarray_modify"]
\<close>

end
